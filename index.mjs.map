{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isPlainObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport { isPrimitive as isFinite } from '@stdlib/assert-is-finite'; // eslint-disable-line stdlib/no-redeclare\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// VARIABLES //\n\nvar returns = [\n\t'terms',\n\t'convergents',\n\t'*'\n];\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {NonNegativeInteger} [options.iter] - maximum number of iterations\n* @param {PositiveNumber} [options.tol] - tolerance at which to terminate further evaluation of the continued fraction\n* @param {string} [options.returns] - specifies the type of result to return (must be one of `'terms'`, `'convergents'`, or `'*'`)\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'iter': 50\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isPlainObject( options ) ) {\n\t\treturn new TypeError( format( '0Hs2h', options ) );\n\t}\n\tif ( hasOwnProp( options, 'iter' ) ) {\n\t\topts.iter = options.iter;\n\t\tif ( !isNonNegativeInteger( options.iter ) ) {\n\t\t\treturn new TypeError( format( '0Hs35', 'iter', options.iter ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'tol' ) ) {\n\t\topts.tol = options.tol;\n\t\tif ( !isFinite( options.tol ) || options.tol <= 0.0 ) {\n\t\t\treturn new TypeError( format( '0Hs4e', 'tol', options.tol ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'returns' ) ) {\n\t\topts.returns = options.returns;\n\t\tif ( returns.indexOf( options.returns ) === -1 ) {\n\t\t\treturn new TypeError( format( '0Hs3t', 'returns', returns.join( '\", \"' ), options.returns ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport { isPrimitive as isFinite } from '@stdlib/assert-is-finite'; // eslint-disable-line stdlib/no-redeclare\nimport iteratorSymbol from '@stdlib/symbol-iterator';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport floor from '@stdlib/math-base-special-floor';\nimport abs from '@stdlib/math-base-special-abs';\nimport EPS from '@stdlib/constants-float64-eps';\nimport FIFO from '@stdlib/utils-fifo';\nimport validate from './validate.js';\n\n\n// VARIABLES //\n\nvar TINY = 1.0e-50;\nvar RESULT_FUNCTION = {\n\t'terms': terms,\n\t'convergents': convergents,\n\t'*': both\n};\n\n\n// FUNCTIONS //\n\n/**\n* Returns a continued fraction term result.\n*\n* @private\n* @param {number} term - continued fraction term\n* @param {number} convergent - continued fraction convergent\n* @param {boolean} negative - boolean indicating whether the input value is negative\n* @returns {number} term\n*/\nfunction terms( term, convergent, negative ) {\n\treturn ( negative && term > 0 ) ? -term : term;\n}\n\n/**\n* Returns a continued fraction convergent result.\n*\n* @private\n* @param {number} term - continued fraction term\n* @param {number} convergent - continued fraction convergent\n* @param {boolean} negative - boolean indicating whether the input value is negative\n* @returns {number} convergent\n*/\nfunction convergents( term, convergent, negative ) {\n\treturn ( negative && term > 0 ) ? -convergent : convergent;\n}\n\n/**\n* Returns a result as two-element array consisting of a continued fraction term and its associated convergent.\n*\n* @private\n* @param {number} term - continued fraction term\n* @param {number} convergent - continued fraction convergent\n* @param {boolean} negative - boolean indicating whether the input value is negative\n* @returns {Array<number>} result\n*/\nfunction both( term, convergent, negative ) {\n\treturn ( negative && term > 0 ) ? [ -term, -convergent ] : [ term, convergent ]; // eslint-disable-line max-len\n}\n\n\n// MAIN //\n\n/**\n* Returns an iterator which generates a list of all continued fraction terms which can be obtained given the precision of `x`.\n*\n* ## Notes\n*\n* -   If an environment supports `Symbol.iterator`, the returned iterator is iterable.\n*\n* @param {number} x - input value\n* @param {Options} [options] - function options\n* @param {NonNegativeInteger} [options.iter=1e308] - maximum number of iterations\n* @param {PositiveNumber} [options.tol] - tolerance at which to terminate further evaluation of the continued fraction\n* @param {string} [options.returns='terms'] - specifies the type of result to return (must be one of `'terms'`, `'convergents'`, or `'*'`)\n* @throws {TypeError} first argument must be a finite number\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Iterator} iterator\n*\n* @example\n* var iter = iterContinuedFractionSeq( 3.245 );\n*\n* var v = iter.next().value;\n* // returns 3\n*\n* v = iter.next().value;\n* // returns 4\n*\n* v = iter.next().value;\n* // returns 12\n*\n* v = iter.next().value;\n* // returns 4\n*\n* var bool = iter.next().done;\n* // returns true\n*/\nfunction iterContinuedFractionSeq( x, options ) {\n\tvar result;\n\tvar delta;\n\tvar orig;\n\tvar opts;\n\tvar iter;\n\tvar FLG;\n\tvar err;\n\tvar neg;\n\tvar bi;\n\tvar fi;\n\tvar Ci;\n\tvar Di;\n\tvar q;\n\tvar v;\n\tvar r;\n\tvar i;\n\n\tif ( !isFinite( x ) ) {\n\t\tthrow new TypeError( format( '0Hs4d', x ) );\n\t}\n\topts = {\n\t\t'iter': 1e308,\n\t\t'tol': EPS,\n\t\t'returns': 'terms'\n\t};\n\tif ( arguments.length > 1 ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tresult = RESULT_FUNCTION[ opts.returns ];\n\tFLG = 0;\n\torig = x;\n\n\t// If `x < 0`, we choose to negate the terms (i.e., [b0; b1, b2, ..., bn] => [-b0; -b1, -b2, ..., -bn]), thus allowing the evaluation of those terms to return the input value. This differs from an alternative approach of having only a negative `b0` and the rest `{b1, ..., bn}` be positive. When doing the latter, floating-point rounding error can prevent recovering the original value...\n\tif ( x < 0 ) {\n\t\tneg = true;\n\t\tx = -x;\n\t} else {\n\t\tneg = false;\n\t}\n\ti = 0;\n\n\t// Create an iterator protocol-compliant object:\n\titer = {};\n\tsetReadOnly( iter, 'next', next );\n\tsetReadOnly( iter, 'return', end );\n\n\t// If an environment supports `Symbol.iterator`, make the iterator iterable:\n\tif ( iteratorSymbol ) {\n\t\tsetReadOnly( iter, iteratorSymbol, factory );\n\t}\n\t// Continued fractions may not be unique (e.g., [b0; b1, ..., bn, 1] = [b0; b1, ..., bn+1]). Accordingly, in order to ensure we return a canonical representation (i.e., the shorter representation), returned values must lag by two terms, as we'll need to peek ahead to determine if we need to canonicalize before returning the last term. In which case, let's create a FIFO queue for storing terms and their associated convergents...\n\tq = new FIFO();\n\n\t// Extract the integer part of the provided value:\n\tbi = floor( x );\n\tq.push( [ bi, bi ] ); // b0 is both the first term and the first convergent\n\tif ( bi === x ) {\n\t\t// We've been provided an integer value, so no continued fractions to compute...\n\t\tFLG = 1;\n\t\treturn iter;\n\t}\n\t// For `0 < x < 1`, leverage the fact that continued fraction representations of a positive rational number and its reciprocal are identical, except for shifting one place to the right (i.e., [b0; b1, b1, ..., bn] and [0; b0, b1, b2, ..., bn] are reciprocals)...\n\tif ( bi === 0 ) {\n\t\tx = 1.0 / x;\n\t\tbi = floor( x );\n\t\tq.push( [ bi, 1.0/bi ] );\n\t\tif ( bi === x ) {\n\t\t\t// No more continued fractions to compute...\n\t\t\tFLG = 1;\n\t\t\treturn iter;\n\t\t}\n\t}\n\t// Compute the next term of the continued fraction...\n\tr = x - bi;\n\tv = 1.0 / r;\n\n\t// Initialize parameters of the modified Lentz's algorithm...\n\tfi = bi;\n\tCi = fi;\n\tDi = 0.0;\n\n\t// Compute the next two terms:\n\tq.push( nextTerm() );\n\tq.push( nextTerm() );\n\n\treturn iter;\n\n\t/**\n\t* Computes the next term of the continued fraction.\n\t*\n\t* @private\n\t* @returns {number} next term\n\t*/\n\tfunction nextTerm() {\n\t\tvar fj = fi;\n\n\t\t// Compute the next term of the continued fraction...\n\t\tbi = floor( v );\n\t\tr = v - bi;\n\t\tv = 1.0 / r;\n\n\t\t// Use the modified Lentz's algorithm to find the next convergent...\n\t\tDi += bi;             // b_j + a_j*D_{j-1}, where a_j = 1.0 for all j\n\t\tif ( Di === 0.0 ) {\n\t\t\tDi = TINY;\n\t\t}\n\t\tCi = bi + ( 1.0/Ci ); // b_j + a_j/C_{j-1}, where a_j = 1.0 for all j\n\t\tif ( Ci === 0.0 ) {\n\t\t\tCi = TINY;\n\t\t}\n\t\tDi = 1.0 / Di;\n\t\tdelta = Ci * Di;\n\t\tfi *= delta;\n\n\t\t// Check whether we can terminate computation...\n\t\tif ( abs( delta - 1.0 ) <= opts.tol ) {\n\t\t\tFLG = 1;\n\t\t\tif ( fj === fi ) {\n\t\t\t\t// Return a sentinel value to indicate that the last term did not improve the approximation:\n\t\t\t\treturn [ -1, fi ];\n\t\t\t}\n\t\t}\n\t\treturn [ bi, fi ];\n\t}\n\n\t/**\n\t* Returns an iterator protocol-compliant object containing the next iterated value.\n\t*\n\t* @private\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction next() {\n\t\tvar item;\n\t\tvar term;\n\t\tvar f;\n\n\t\ti += 1;\n\t\tif ( FLG > 0 ) {\n\t\t\tif ( FLG === 1 && q.length > 0 ) {\n\t\t\t\titem = q.pop();\n\t\t\t\tterm = item[ 0 ];\n\t\t\t\tf = item[ 1 ];\n\t\t\t\tif ( term === -1 ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'done': true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Check whether we need to adjust the current term to ensure canonical representation...\n\t\t\t\titem = q.first();\n\t\t\t\tif ( q.length === 2 && item[ 0 ] === 1 ) {\n\t\t\t\t\tterm += 1;\n\t\t\t\t\tf = item[ 1 ];\n\t\t\t\t\tq.clear();\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t'value': result( term, f, neg ),\n\t\t\t\t\t'done': false\n\t\t\t\t};\n\t\t\t}\n\t\t\tFLG = 2;\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\tif ( i === opts.iter ) {\n\t\t\titem = q.pop();\n\t\t\tterm = item[ 0 ];\n\t\t\tf = item[ 1 ];\n\n\t\t\t// Check whether we need to adjust the final term to ensure canonical representation...\n\t\t\titem = q.first();\n\t\t\tif ( item[ 0 ] === 1 ) {\n\t\t\t\tterm += 1;\n\t\t\t\tf = item[ 1 ];\n\t\t\t}\n\t\t\tq.clear();\n\t\t\tFLG = 2;\n\t\t\treturn {\n\t\t\t\t'value': result( term, f, neg ),\n\t\t\t\t'done': false\n\t\t\t};\n\t\t}\n\t\titem = q.push( nextTerm() ).pop();\n\t\treturn {\n\t\t\t'value': result( item[ 0 ], item[ 1 ], neg ),\n\t\t\t'done': false\n\t\t};\n\t}\n\n\t/**\n\t* Finishes an iterator.\n\t*\n\t* @private\n\t* @param {*} [value] - value to return\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction end( value ) {\n\t\tFLG = 2;\n\t\tif ( arguments.length ) {\n\t\t\treturn {\n\t\t\t\t'value': value,\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'done': true\n\t\t};\n\t}\n\n\t/**\n\t* Returns a new iterator.\n\t*\n\t* @private\n\t* @returns {Iterator} iterator\n\t*/\n\tfunction factory() {\n\t\treturn iterContinuedFractionSeq( orig, opts );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default iterContinuedFractionSeq;\n"],"names":["returns","validate","opts","options","isPlainObject","hasOwnProp","iter","isNonNegativeInteger","TypeError","format","tol","isFinite","indexOf","join","RESULT_FUNCTION","terms","term","convergent","negative","convergents","iterContinuedFractionSeq","x","result","delta","orig","FLG","err","neg","bi","fi","Ci","Di","q","v","i","EPS","arguments","length","setReadOnly","next","end","iteratorSymbol","factory","FIFO","floor","push","nextTerm","fj","abs","item","f","pop","done","first","clear","value"],"mappings":"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"}